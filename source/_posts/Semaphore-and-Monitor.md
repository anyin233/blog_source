---
title: 信号量机制与管程
date: 2020-11-18 19:38:10
tags: 操作系统
---

## 信号量机制
信号量机制最早由提出图论的Dijkstra提出，其被广泛地使用于操作系统中用于解决同步问题。

### 信号量简介
信号量一般由以下几部分组成

- 一个整形```sem```  
通常```sem```的值等于共享资源的数量
- 两个操作
    - P操作(又名Wait)  
    P操作通常用于申请资源，其的主要过程一般为
        - ```sem -= 1```
        - 当```sem < 0```block当前进(线)程，并放入等待队列中
    - V操作(又名Signal)  
    V操作通常用于释放资源，其的主要过程一般为
        - ```sem += 1```
        - 当```sem <=0 ```时从等待队列中取出一个进(线)程，并唤醒

借助信号量机制，我们可以解决很多的多进(线)程间同步的问题。接下来我们将会使用几个例子来进一步地了解信号量的作用。

### 生产者-消费者问题
生产者-消费者问题是一个非常著名的多线程间同步的问题，接下来我们将会围绕这个问题探讨信号量机制的意义。

首先我们假设现在我们有一个盒子，x个消费者和y个生产者。并且我们规定同时可以有消费者从盒子中取出东西，同时只能由一位生产者向盒子中放入东西，且消费者和生产者同样不能同时从盒子中取出或者放入东西。

#### 情景0：多消费者-无生产者-盒子内的资源无限

情景0并不是定义上的生产者-消费者问题，这种情况只是提出用于具体了解信号量的工作方式的情景，故在本情景中我们假设同时只能有一位消费者从盒子中取出东西。  
这种情况实际上可以退化为多个等价的个体竞争一个资源的情况，由于我们规定了盒子同时只能由一位消费者进行访问，所以我们这里就可以使用一个信号量表示盒子的占用情况，由上文中的信号量的定义我们可以得知当任何消费者对盒子进行访问后下一次对```res.wait()```的调用就会将新的进程阻塞，直到访问盒子的消费者调用```res.signal()```进行唤醒。
```rust
let res: Semaphore = 1;

fn consumer(){
    res.wait();
    //对盒子中的资源进行消费
    res.signal();
}
```

#### 情景1：单消费者-单生产者-盒子容量为一

从情景1开始才是真正意义上的消费者生产者问题，但是这里我们还是限制了消费者和生产者的数量均为1。对于本情景中的条件，我们可以构造得到下述的伪代码
```rust
let full: Semaphore = 0;
let empty: Semaphore = 1;

fn consumer(){
    full.wait();
    //对盒子内的资源进行消费
    empty.signal();
}

fn provider(){
    empty.wait();
    //向盒子中生产内容
    full.signal();
}
```
从上面的代码就可以看到我们创建了两个信号量而非一个，原因也很简单，当盒子为空的时候消费者无法进行消费，当盒子为满的时候生产者无法进行生产，所以我们就可以让消费者对```full```作```wait()```操作实现空出盒子的空间，同样生产者也可以使用```full.signal()```实现标志盒子中已经放入了资源。